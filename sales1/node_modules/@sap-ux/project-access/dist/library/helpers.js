"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getManifestDependencies = exports.getManifestDesc = exports.getLibraryDependencies = exports.getLibraryDesc = exports.checkDependencies = exports.getReuseLibs = void 0;
const path_1 = require("path");
const constants_1 = require("./constants");
const file_1 = require("../file");
const constants_2 = require("../constants");
const fs_1 = require("fs");
const fast_xml_parser_1 = require("fast-xml-parser");
const i18n_1 = require("../project/i18n");
const i18n_2 = require("@sap-ux/i18n");
/**
 * Reads the manifest file and returns the reuse library.
 *
 * @param manifest - manifest file content
 * @param manifestPath - path to the manifest file
 * @param reuseLibs - existing reuse libraries
 * @param projectRoot - root of the project
 * @returns reuse library or undefined
 */
const getLibraryFromManifest = (manifest, manifestPath, reuseLibs, projectRoot) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c;
    let reuseLib;
    const manifestType = (_a = manifest['sap.app']) === null || _a === void 0 ? void 0 : _a.type;
    if ((manifestType === 'component' || manifestType === 'library') && manifestPath) {
        const reuseType = getReuseType(manifestPath);
        const libDeps = getManifestDependencies(manifest);
        const description = yield getManifestDesc(manifest, manifestPath);
        const libIndex = reuseLibs.findIndex((reuseLib) => reuseLib.name === (manifest === null || manifest === void 0 ? void 0 : manifest['sap.app'].id));
        if (libIndex === -1) {
            reuseLib = {
                name: `${manifest['sap.app'].id}`,
                path: (0, path_1.dirname)(manifestPath),
                type: reuseType,
                uri: (_c = (_b = manifest['sap.platform.abap']) === null || _b === void 0 ? void 0 : _b.uri) !== null && _c !== void 0 ? _c : '',
                dependencies: libDeps,
                libRoot: projectRoot,
                description
            };
        }
    }
    return reuseLib;
});
/**
 * Reads library file and returns a reuse lib object.
 *
 * @param library - library file content
 * @param libraryPath - path to the library file
 * @param projectRoot - root of the project
 * @returns reuse library or undefined
 */
const getLibraryFromLibraryFile = (library, libraryPath, projectRoot) => __awaiter(void 0, void 0, void 0, function* () {
    var _d, _e, _f, _g, _h;
    let libEntry;
    const parsedFile = new fast_xml_parser_1.XMLParser({ removeNSPrefix: true }).parse(library, false);
    if ((_d = parsedFile === null || parsedFile === void 0 ? void 0 : parsedFile.library) === null || _d === void 0 ? void 0 : _d.name) {
        const manifestType = (parsedFile === null || parsedFile === void 0 ? void 0 : parsedFile.library) ? 'library' : 'component';
        if (manifestType === 'component' || manifestType === 'library') {
            const reuseType = getReuseType(libraryPath);
            const libDeps = getLibraryDependencies(parsedFile);
            const description = yield getLibraryDesc(parsedFile, libraryPath);
            libEntry = {
                name: `${parsedFile.library.name}`,
                path: (0, path_1.dirname)(libraryPath),
                type: reuseType,
                uri: ((_h = (_g = (_f = (_e = parsedFile.library) === null || _e === void 0 ? void 0 : _e.appData) === null || _f === void 0 ? void 0 : _f.manifest) === null || _g === void 0 ? void 0 : _g['sap.platform.abap']) === null || _h === void 0 ? void 0 : _h.uri) || '',
                dependencies: libDeps,
                libRoot: projectRoot,
                description
            };
        }
    }
    return libEntry;
});
/**
 * Updates the library options with the new library.
 *
 * @param reuseLibs - existing library options
 * @param reuseLib - new library
 */
const updateLibOptions = (reuseLibs, reuseLib) => {
    if (reuseLib) {
        const libIndex = reuseLibs.findIndex((lib) => lib.name === reuseLib.name);
        if (libIndex >= 0) {
            // replace
            reuseLibs[libIndex] = reuseLib;
        }
        else {
            reuseLibs.push(reuseLib);
        }
    }
};
/**
 * Returns an array of the reuse libraries found in the folders.
 *
 * @param libs - array of libraries found in the workspace folders.
 * @returns list of reuse library
 */
const getReuseLibs = (libs) => __awaiter(void 0, void 0, void 0, function* () {
    const reuseLibs = [];
    if (libs) {
        for (const lib of libs) {
            const excludeFolders = ['.git', 'node_modules', 'dist'];
            const manifestPaths = yield (0, file_1.findFiles)('manifest.json', lib.projectRoot, excludeFolders);
            const libraryPaths = yield (0, file_1.findFiles)('library.js', lib.projectRoot, excludeFolders);
            for (const manifestPath of manifestPaths) {
                const manifestFilePath = (0, path_1.join)(manifestPath, constants_2.FileName.Manifest);
                const manifest = JSON.parse(yield fs_1.promises.readFile(manifestFilePath, { encoding: 'utf8' }));
                const library = yield getLibraryFromManifest(manifest, manifestFilePath, reuseLibs, lib.projectRoot);
                if (library) {
                    reuseLibs.push(library);
                }
            }
            for (const libraryPath of libraryPaths) {
                const libraryFilePath = (0, path_1.join)(libraryPath, constants_2.FileName.Library);
                const library = (yield fs_1.promises.readFile(libraryFilePath, { encoding: 'utf8' })).toString();
                const libFile = yield getLibraryFromLibraryFile(library, libraryFilePath, lib.projectRoot);
                updateLibOptions(reuseLibs, libFile);
            }
        }
    }
    return reuseLibs;
});
exports.getReuseLibs = getReuseLibs;
/**
 * Gets the type of reuse library.
 *
 * @param libraryPath - path to the reuse library
 * @returns the type of reuse library
 */
function getReuseType(libraryPath) {
    return (0, fs_1.existsSync)((0, path_1.join)((0, path_1.dirname)(libraryPath), '/library.js')) ||
        (0, fs_1.existsSync)((0, path_1.join)((0, path_1.dirname)(libraryPath), '/library.ts'))
        ? "library" /* ReuseLibType.Library */
        : "component" /* ReuseLibType.Component */;
}
/**
 * Checks for missing dependencies in the selected reuse libraries.
 *
 * @param answers - reuse libraries selected by the user
 * @param reuseLibs - all available reuse libraries
 * @returns a string with the missing dependencies
 */
function checkDependencies(answers, reuseLibs) {
    const missingDeps = [];
    answers.forEach((answer) => {
        const dependencies = answer.dependencies;
        if (dependencies === null || dependencies === void 0 ? void 0 : dependencies.length) {
            dependencies.forEach((dependency) => {
                if (!reuseLibs.some((lib) => {
                    return dependency === lib.name;
                })) {
                    missingDeps.push(dependency);
                }
            });
        }
    });
    return missingDeps.join();
}
exports.checkDependencies = checkDependencies;
/**
 * Returns the library description.
 *
 * @param library - library object
 * @param libraryPath - library path
 * @returns library description
 */
function getLibraryDesc(library, libraryPath) {
    var _a, _b, _c, _d, _e;
    return __awaiter(this, void 0, void 0, function* () {
        let libraryDesc = (_a = library === null || library === void 0 ? void 0 : library.library) === null || _a === void 0 ? void 0 : _a.documentation;
        if (typeof libraryDesc === 'string' && libraryDesc.startsWith('{{')) {
            const key = libraryDesc.substring(2, libraryDesc.length - 2);
            libraryDesc = yield geti18nPropertyValue((0, path_1.join)((0, path_1.dirname)(libraryPath), (_e = (_d = (_c = (_b = library.library) === null || _b === void 0 ? void 0 : _b.appData) === null || _c === void 0 ? void 0 : _c.manifest) === null || _d === void 0 ? void 0 : _d.i18n) === null || _e === void 0 ? void 0 : _e.toString()), key);
        }
        return libraryDesc.toString();
    });
}
exports.getLibraryDesc = getLibraryDesc;
/**
 * Returns the library dependencies.
 *
 * @param library - library object
 * @returns array of dependencies
 */
function getLibraryDependencies(library) {
    var _a, _b;
    const result = [];
    if ((_b = (_a = library === null || library === void 0 ? void 0 : library.library) === null || _a === void 0 ? void 0 : _a.dependencies) === null || _b === void 0 ? void 0 : _b.dependency) {
        let deps = library.library.dependencies.dependency;
        if (!Array.isArray(deps)) {
            deps = [deps];
        }
        deps.forEach((lib) => {
            // ignore libs that start with SAPUI5 delivered namespaces
            if (!constants_1.ui5Libs.some((substring) => {
                return lib.libraryName === substring || lib.libraryName.startsWith(substring + '.');
            })) {
                result.push(lib.libraryName);
            }
        });
    }
    return result;
}
exports.getLibraryDependencies = getLibraryDependencies;
/**
 * Returns the i18n property value.
 *
 * @param i18nPath - i18n path
 * @param key - property key
 * @returns i18n property value
 */
function geti18nPropertyValue(i18nPath, key) {
    return __awaiter(this, void 0, void 0, function* () {
        let value = '';
        try {
            const bundle = yield (0, i18n_2.getPropertiesI18nBundle)(i18nPath);
            const node = bundle[key].find((i) => i.key.value === key);
            if (node) {
                value = node.value.value;
            }
        }
        catch (e) {
            // ignore exception
        }
        return value;
    });
}
/**
 * Returns the manifest description.
 *
 * @param manifest - manifest object
 * @param manifestPath - manifestPath path
 * @returns manifest description
 */
function getManifestDesc(manifest, manifestPath) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        let manifestDesc = (_a = manifest['sap.app']) === null || _a === void 0 ? void 0 : _a.description;
        if (typeof manifestDesc === 'string' && manifestDesc.startsWith('{{')) {
            const key = manifestDesc.substring(2, manifestDesc.length - 2);
            const { 'sap.app': i18nPath } = yield (0, i18n_1.getI18nPropertiesPaths)(manifestPath, manifest);
            manifestDesc = yield geti18nPropertyValue(i18nPath, key);
        }
        return (manifestDesc !== null && manifestDesc !== void 0 ? manifestDesc : '').toString();
    });
}
exports.getManifestDesc = getManifestDesc;
/**
 * Returns the manifest dependencies.
 *
 * @param manifest - manifest object
 * @returns array of dependencies
 */
function getManifestDependencies(manifest) {
    const result = [];
    Object.values(['libs', 'components']).forEach((reuseType) => {
        var _a, _b, _c, _d;
        const dependencies = (_b = (_a = manifest['sap.ui5']) === null || _a === void 0 ? void 0 : _a.dependencies) === null || _b === void 0 ? void 0 : _b[reuseType];
        if (dependencies) {
            const libs = (_d = (_c = manifest === null || manifest === void 0 ? void 0 : manifest['sap.ui5']) === null || _c === void 0 ? void 0 : _c.dependencies) === null || _d === void 0 ? void 0 : _d.libs;
            if (libs) {
                Object.keys(libs).forEach((manifestLibKey) => {
                    // ignore libs that start with SAPUI5 delivered namespaces
                    if (!constants_1.ui5Libs.some((substring) => {
                        return manifestLibKey === substring || manifestLibKey.startsWith(substring + '.');
                    })) {
                        result.push(manifestLibKey);
                    }
                });
            }
        }
    });
    return result;
}
exports.getManifestDependencies = getManifestDependencies;
//# sourceMappingURL=helpers.js.map